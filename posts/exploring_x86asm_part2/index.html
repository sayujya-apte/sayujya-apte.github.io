<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Exploring x86 ASM : Runtime code modification and creating mutating programs | Sayujya Apte</title>
<meta name="keywords" content="">
<meta name="description" content="Code, once written by the programmer and compiled into an executable, is usually treated as immutable. Yet, at the lowest level of execution, this immutability is more of a suggestion than a rule, enforced by operating systems rather than the hardware itself. In reality, code is just stored in the memory within the text section, and as you can with any other location in memory, you can modify it at runtime, given that you have the right privileges.">
<meta name="author" content="">
<link rel="canonical" href="https://sayujya-apte.github.io/posts/exploring_x86asm_part2/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.7da7716a1f2d0725f74c6ae7f8d6adafc43aabe2b366b65bfbf433448e2a2001.css" integrity="sha256-fadxah8tByX3TGrn&#43;Natr8Q6q&#43;KzZrZb&#43;/QzRI4qIAE=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://sayujya-apte.github.io/favicon.ico">
<link rel="apple-touch-icon" href="https://sayujya-apte.github.io/apple-touch-icon.png">
<link rel="alternate" hreflang="en" href="https://sayujya-apte.github.io/posts/exploring_x86asm_part2/">

<meta name="twitter:title" content="Exploring x86 ASM : Runtime code modification and creating mutating programs | Sayujya Apte" />
<meta name="twitter:description" content="Code, once written by the programmer and compiled into an executable, is usually treated as immutable. Yet, at the lowest level of execution, this immutability is more of a suggestion than a rule, enforced by operating systems rather than the hardware itself. In reality, code is just stored in the memory within the text section, and as you can with any other location in memory, you can modify it at runtime, given that you have the right privileges." />
<meta property="og:title" content="Exploring x86 ASM : Runtime code modification and creating mutating programs | Sayujya Apte" />
<meta property="og:description" content="Code, once written by the programmer and compiled into an executable, is usually treated as immutable. Yet, at the lowest level of execution, this immutability is more of a suggestion than a rule, enforced by operating systems rather than the hardware itself. In reality, code is just stored in the memory within the text section, and as you can with any other location in memory, you can modify it at runtime, given that you have the right privileges." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://sayujya-apte.github.io/posts/exploring_x86asm_part2/" />
<meta property="article:section" content="posts" />
  <meta property="article:published_time" content="2026-01-19T21:24:32&#43;00:00" />
  <meta property="article:modified_time" content="2026-01-19T21:24:32&#43;00:00" />


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://sayujya-apte.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Exploring x86 ASM : Runtime code modification and creating mutating programs",
      "item": "https://sayujya-apte.github.io/posts/exploring_x86asm_part2/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Exploring x86 ASM : Runtime code modification and creating mutating programs | Sayujya Apte",
  "name": "Exploring x86 ASM : Runtime code modification and creating mutating programs",
  "description": "Code, once written by the programmer and compiled into an executable, is usually treated as immutable. Yet, at the lowest level of execution, this immutability is more of a suggestion than a rule, enforced by operating systems rather than the hardware itself. In reality, code is just stored in the memory within the text section, and as you can with any other location in memory, you can modify it at runtime, given that you have the right privileges.\n",
  "keywords": [
    
  ],
  "wordCount" : "967",
  "inLanguage": "en",
  "datePublished": "2026-01-19T21:24:32Z",
  "dateModified": "2026-01-19T21:24:32Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://sayujya-apte.github.io/posts/exploring_x86asm_part2/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Sayujya Apte",
    "logo": {
      "@type": "ImageObject",
      "url": "https://sayujya-apte.github.io/favicon.ico"
    }
  }
}
</script>
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript>

</head>

<body class=" dark type-posts kind-page layout-" id="top"><script data-no-instant>
function switchTheme(theme) {
  switch (theme) {
    case 'light':
      document.body.classList.remove('dark');
      break;
    case 'dark':
      document.body.classList.add('dark');
      break;
    
    default:
      if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
      }
  }
}

function isDarkTheme() {
  return document.body.className.includes("dark");
}

function getPrefTheme() {
  return localStorage.getItem("pref-theme");
}

function setPrefTheme(theme) {
  switchTheme(theme)
  localStorage.setItem("pref-theme", theme);
}

const toggleThemeCallbacks = {}
toggleThemeCallbacks['main'] = (isDark) => {
  
  if (isDark) {
    setPrefTheme('light');
  } else {
    setPrefTheme('dark');
  }
}




window.addEventListener('toggle-theme', function() {
  
  const isDark = isDarkTheme()
  for (const key in toggleThemeCallbacks) {
    toggleThemeCallbacks[key](isDark)
  }
});


function toggleThemeListener() {
  
  window.dispatchEvent(new CustomEvent('toggle-theme'));
}

</script>
<script>
  
  (function() {
    const defaultTheme = 'dark';
    const prefTheme = getPrefTheme();
    const theme = prefTheme ? prefTheme : defaultTheme;

    switchTheme(theme);
  })();
</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://sayujya-apte.github.io/" accesskey="h" title="Sayujya Apte (Alt + H)">Sayujya Apte</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
        </ul>
    </nav>
</header>
<main class="main post">

<article class="post-single">
  <header class="post-header">
    <h1 class="post-title">Exploring x86 ASM : Runtime code modification and creating mutating programs</h1>
    <div class="post-meta"><span class="meta-item">
  <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar" style="user-select: text;"><rect x="3" y="4" width="18" height="18" rx="2" ry="2" style="user-select: text;"></rect><line x1="16" y1="2" x2="16" y2="6" style="user-select: text;"></line><line x1="8" y1="2" x2="8" y2="6" style="user-select: text;"></line><line x1="3" y1="10" x2="21" y2="10" style="user-select: text;"></line></svg>
  <span>January 19, 2026</span></span>

      
      
    </div>
  </header> 
  <div class="post-content"><p>Code, once written by the programmer and compiled into an executable, is usually treated as immutable. Yet, at the lowest level of execution, this immutability is more of a suggestion than a rule, enforced by operating systems rather than the hardware itself. In reality, code is just stored in the memory within the text section, and as you can with any other location in memory, you can modify it at runtime, given that you have the right privileges.</p>
<p>This simple realisation opens the door to several possibilities - the greatest being the ability to create programs that can mutate themselves at runtime. Functions, that are programmed to do one task, but end up doing something else entirely. In this post, we explore how we can create such mutating programs, what uses do they have, and why they can be potentially dangerous.</p>
<h2 id="the-background">The Background<a hidden class="anchor" aria-hidden="true" href="#the-background">¶</a></h2>
<p>In a program&rsquo;s memory, code is stored as instructions in the text section. These instructions are stored in the typical opcode-operand format. Now, if a different instruction changes the value of either the opcode or the operand at the memory location of the first instruction, the first instruction has been mutated. The CPU itself won&rsquo;t object to this, because it only reads and interprets the memory.</p>
<p>The only thing stopping someone from doing so is the operating system. In a typical program, different sections of memory are assigned different privileges. Each segment has three permission bits - read, write, and execute. The text segment of the program conventionally only has read and execute privileges. This provision exists for several purposes, such as preventing malicious attacks by intjecting executable code, or preventing bugs from corrupting program logic. In fact, the CPU can even cache the code more aggressively if it knows that it won&rsquo;t change.</p>
<h2 id="the-implementation">The Implementation<a hidden class="anchor" aria-hidden="true" href="#the-implementation">¶</a></h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-nasm" data-lang="nasm"><span style="display:flex;"><span><span style="color:#66d9ef">section</span> .data
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">SYSCALL_write</span> db <span style="color:#ae81ff">4</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">SYSCALL_mprotect</span> db <span style="color:#ae81ff">125</span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">PROT_READ</span><span style="color:#66d9ef"> equ</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">PROT_WRITE</span><span style="color:#66d9ef"> equ</span> <span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">PROT_EXEC</span><span style="color:#66d9ef"> equ</span> <span style="color:#ae81ff">4</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">PROT_RWX</span><span style="color:#66d9ef"> equ</span> (PROT_READ <span style="color:#f92672">|</span> PROT_WRITE <span style="color:#f92672">|</span> PROT_EXEC)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">newline</span> db <span style="color:#ae81ff">10</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">section</span> .bss
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">result</span> rsb <span style="color:#ae81ff">4</span>        <span style="color:#75715e">; Result buffer to temporarily store value</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">section</span> .text
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">global</span> _start
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>modifiable_func:
</span></span><span style="display:flex;"><span>instr_to_modify:
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">mov</span> eax, <span style="color:#ae81ff">5</span>          <span style="color:#75715e">; Instruction that we intend to modify</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">ret</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>_start:
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">mov</span> eax, SYSCALL_mprotect       <span style="color:#75715e">; mprotect syscall</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">mov</span> ebx, modifiable_func        <span style="color:#75715e">; ebx contains memory address (for mprotect)</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">and</span> ebx, <span style="color:#ae81ff">0xFFFFF000</span>             <span style="color:#75715e">; align the memory address to the page boundary</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">mov</span> ecx, <span style="color:#ae81ff">4096</span>                   <span style="color:#75715e">; ecx contains the size of the memory block (for mprotect)</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">mov</span> edx, PROT_RWX               <span style="color:#75715e">; edx contains the new protection flags (for mprotect)</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">int</span> <span style="color:#ae81ff">0x80</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">call</span> modifiable_func            <span style="color:#75715e">; First time we call, the value in eax will be 5</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">mov</span> eax, [result]
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">mov</span> eax, SYSCALL_write
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">mov</span> ebx, <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">mov</span> ecx, result
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">mov</span> edx, <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">int</span> <span style="color:#ae81ff">0x80</span>                        <span style="color:#75715e">; Output : 5</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">mov</span> eax, SYSCALL_write
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">mov</span> ebx, <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">mov</span> ecx, newline
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">mov</span> edx, <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">int</span> <span style="color:#ae81ff">0x80</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">mov</span> <span style="color:#66d9ef">byte</span> [instr_to_modify <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>], <span style="color:#ae81ff">6</span> <span style="color:#75715e">; Modifying the opcode of the given instruction</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">call</span> modifiable_func            <span style="color:#75715e">; Second time we call, the value in eax will be 6</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">mov</span> eax, [result]
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">mov</span> eax, SYSCALL_write
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">mov</span> ebx, <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">mov</span> ecx, result
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">mov</span> edx, <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">int</span> <span style="color:#ae81ff">0x80</span>                        <span style="color:#75715e">; Output : 6</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">mov</span> eax, <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">xor</span> ebx, ebx
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">int</span> <span style="color:#ae81ff">0x80</span>
</span></span></code></pre></div><p>In the above program, we have declared the function we intend to modify in the text section. Additionally, we have also added a label to the specific instruction that we want to modify.</p>
<p>At the very beginning of the <code>_start</code> function, we make a system call to <code>mprotect</code>. <code>mprotect</code> is the syscall used to change the memory access protections for the calling process&rsquo;s memory pages. The function takes in the address, aligned to a page boundary, a size, the size of the page in consideration, and the new protection flags that are to be assigned to the memory block. In this case, we pass the address of the modifiable function, along with a page size of 4096, and requesting privileges to read, write, and execute.</p>
<p>Then, the program calls the modifiable function, which places 5 in the <code>eax</code> register. It then print the contents of <code>eax</code>. After this, the program actually starts mutating code. It goes to the memory location of the instruction to be modified, moves one byte further (that one byte corresponds to the opcode), and changes the operand from a 5 to a 6. And after calling the function and printing the contents of <code>eax</code>, we can see that the mutation has succeeded.</p>
<h2 id="applications">Applications<a hidden class="anchor" aria-hidden="true" href="#applications">¶</a></h2>
<p>Practical applications of self-modifying code are few and far between. From an optimization standpoint, mutating code can be used to optimize loops via unrolling and dynamically adjusting loop counters based on runtime data sizes, however any benefit gained from this will be negated by the performance drop caused by the loss of cacheing of instructions.</p>
<p>A more realistic use of this can be in DRM protection and anti-reverse engineering measures. For example, if a program detects that it is being run inside a debugger, it will intentionally abstract and obfuscate the code to prevent analysis and subsequent reverse engineering.</p>
<p>However, this paradigm can also lead itself to more malicious applications. Using this technique, one can create a polymorphic virus, with code that mutates with every infection. Changing minor things, like the instruction order or registers used can be enough to morph the signature enough and evade detection. This technique can also be used to create runtime metamorphic viruses, where the virus changes its own code completely while still preserving its funcion.</p>
<h2 id="conclusion">Conclusion<a hidden class="anchor" aria-hidden="true" href="#conclusion">¶</a></h2>
<p>Just like most of my previous projects, this one as well is not something that should be applied in the real world. However, watching a function return different values from the exact same function call, knowing I had rewritten the instructions within mid-execution, gave me a visceral understanding of how fragile the boundary between code and data really is. The full source code of the program can be found here.</p>


  </div>

  <footer class="post-footer">
  </footer>
    <div class="comments-separator"></div>
</article>
    </main>
    
<footer class="footer">
  <span>&copy; 2026 <a href="https://sayujya-apte.github.io/">Sayujya Apte</a></span><span style="display: inline-block; margin-left: 1em;">
    <a href="https://creativecommons.org/licenses/by-sa/4.0/">CC BY-SA</a>
  </span>
  <span style="display: inline-block; margin-left: 1em;">
    Powered by
    <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
    <a href="https://github.com/reorx/hugo-PaperModX/" rel="noopener" target="_blank">PaperModX</a>
  </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
    <path d="M12 6H0l6-6z" />
  </svg>
</a>

<script>
  (function() {
     
    const disableThemeToggle = '' == '1';
    if (disableThemeToggle) {
      return;
    }

    let button = document.getElementById("theme-toggle")
    
    button.removeEventListener('click', toggleThemeListener)
    
    button.addEventListener('click', toggleThemeListener)
  })();
</script>

<script>
  (function () {
    let menu = document.getElementById('menu')
    if (menu) {
      menu.scrollLeft = localStorage.getItem("menu-scroll-position");
      menu.onscroll = function () {
        localStorage.setItem("menu-scroll-position", menu.scrollLeft);
      }
    }

    const disableSmoothScroll = '' == '1';
    const enableInstantClick = '' == '1';
    
    if (window.matchMedia('(prefers-reduced-motion: reduce)').matches || disableSmoothScroll || enableInstantClick) {
      return;
    }
    
    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
      anchor.addEventListener("click", function (e) {
        e.preventDefault();
        var id = this.getAttribute("href").substr(1);
        document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
          behavior: "smooth"
        });
        if (id === "top") {
          history.replaceState(null, null, " ");
        } else {
          history.pushState(null, null, `#${id}`);
        }
      });
    });
  })();
</script>
<script>
  var mybutton = document.getElementById("top-link");
  window.onscroll = function () {
    if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
      mybutton.style.visibility = "visible";
      mybutton.style.opacity = "1";
    } else {
      mybutton.style.visibility = "hidden";
      mybutton.style.opacity = "0";
    }
  };
</script>
<script>
  if (window.scrollListeners) {
    
    for (const listener of scrollListeners) {
      window.removeEventListener('scroll', listener)
    }
  }
  window.scrollListeners = []
</script>



<script src="/js/medium-zoom.min.js" data-no-instant
></script>




<script>
  
  
  (function() {
    const enableTocScroll = '' == '1'
    if (!enableTocScroll) {
      return
    }
    if (!document.querySelector('.toc')) {
      console.log('no toc found, ignore toc scroll')
      return
    }
    

    
    const scrollListeners = window.scrollListeners
    const headings = document.querySelectorAll('h1[id],h2[id],h3[id],h4[id],h5[id]');
    const activeClass = 'active';

    
    let activeHeading = headings[0];
    getLinkByHeading(activeHeading).classList.add(activeClass);

    const onScroll = () => {
      const passedHeadings = [];
      for (const h of headings) {
        
        if (getOffsetTop(h) < 5) {
          passedHeadings.push(h)
        } else {
          break;
        }
      }
      if (passedHeadings.length > 0) {
        newActiveHeading = passedHeadings[passedHeadings.length - 1];
      } else {
        newActiveHeading = headings[0];
      }
      if (activeHeading != newActiveHeading) {
        getLinkByHeading(activeHeading).classList.remove(activeClass);
        activeHeading = newActiveHeading;
        getLinkByHeading(activeHeading).classList.add(activeClass);
      }
    }

    let timer = null;
    const scrollListener = () => {
      if (timer !== null) {
        clearTimeout(timer)
      }
      timer = setTimeout(onScroll, 50)
    }
    window.addEventListener('scroll', scrollListener, false);
    scrollListeners.push(scrollListener)

    function getLinkByHeading(heading) {
      const id = encodeURI(heading.getAttribute('id')).toLowerCase();
      return document.querySelector(`.toc ul li a[href="#${id}"]`);
    }

    function getOffsetTop(heading) {
      if (!heading.getClientRects().length) {
        return 0;
      }
      let rect = heading.getBoundingClientRect();
      return rect.top
    }
  })();
  </script>

</body>

</html>

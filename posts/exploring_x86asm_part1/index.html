<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Exploring x86 ASM : Building my own malloc and free | Sayujya Apte</title>
<meta name="keywords" content="">
<meta name="description" content="Implementing memory management at the lowest level using Linux syscalls">
<meta name="author" content="">
<link rel="canonical" href="https://sayujya-apte.github.io/posts/exploring_x86asm_part1/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.7da7716a1f2d0725f74c6ae7f8d6adafc43aabe2b366b65bfbf433448e2a2001.css" integrity="sha256-fadxah8tByX3TGrn&#43;Natr8Q6q&#43;KzZrZb&#43;/QzRI4qIAE=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://sayujya-apte.github.io/favicon.ico">
<link rel="apple-touch-icon" href="https://sayujya-apte.github.io/apple-touch-icon.png">
<link rel="alternate" hreflang="en" href="https://sayujya-apte.github.io/posts/exploring_x86asm_part1/">

<meta name="twitter:title" content="Exploring x86 ASM : Building my own malloc and free | Sayujya Apte" />
<meta name="twitter:description" content="Implementing memory management at the lowest level using Linux syscalls" />
<meta property="og:title" content="Exploring x86 ASM : Building my own malloc and free | Sayujya Apte" />
<meta property="og:description" content="Implementing memory management at the lowest level using Linux syscalls" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://sayujya-apte.github.io/posts/exploring_x86asm_part1/" />
<meta property="article:section" content="posts" />
  <meta property="article:published_time" content="2025-11-17T19:20:43&#43;00:00" />
  <meta property="article:modified_time" content="2025-11-17T19:20:43&#43;00:00" />


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://sayujya-apte.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Exploring x86 ASM : Building my own malloc and free",
      "item": "https://sayujya-apte.github.io/posts/exploring_x86asm_part1/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Exploring x86 ASM : Building my own malloc and free | Sayujya Apte",
  "name": "Exploring x86 ASM : Building my own malloc and free",
  "description": "Implementing memory management at the lowest level using Linux syscalls",
  "keywords": [
    
  ],
  "wordCount" : "1346",
  "inLanguage": "en",
  "datePublished": "2025-11-17T19:20:43Z",
  "dateModified": "2025-11-17T19:20:43Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://sayujya-apte.github.io/posts/exploring_x86asm_part1/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Sayujya Apte",
    "logo": {
      "@type": "ImageObject",
      "url": "https://sayujya-apte.github.io/favicon.ico"
    }
  }
}
</script>
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript>

</head>

<body class=" dark type-posts kind-page layout-" id="top"><script data-no-instant>
function switchTheme(theme) {
  switch (theme) {
    case 'light':
      document.body.classList.remove('dark');
      break;
    case 'dark':
      document.body.classList.add('dark');
      break;
    
    default:
      if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
      }
  }
}

function isDarkTheme() {
  return document.body.className.includes("dark");
}

function getPrefTheme() {
  return localStorage.getItem("pref-theme");
}

function setPrefTheme(theme) {
  switchTheme(theme)
  localStorage.setItem("pref-theme", theme);
}

const toggleThemeCallbacks = {}
toggleThemeCallbacks['main'] = (isDark) => {
  
  if (isDark) {
    setPrefTheme('light');
  } else {
    setPrefTheme('dark');
  }
}




window.addEventListener('toggle-theme', function() {
  
  const isDark = isDarkTheme()
  for (const key in toggleThemeCallbacks) {
    toggleThemeCallbacks[key](isDark)
  }
});


function toggleThemeListener() {
  
  window.dispatchEvent(new CustomEvent('toggle-theme'));
}

</script>
<script>
  
  (function() {
    const defaultTheme = 'dark';
    const prefTheme = getPrefTheme();
    const theme = prefTheme ? prefTheme : defaultTheme;

    switchTheme(theme);
  })();
</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://sayujya-apte.github.io/" accesskey="h" title="Sayujya Apte (Alt + H)">Sayujya Apte</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
        </ul>
    </nav>
</header>
<main class="main post">

<article class="post-single">
  <header class="post-header">
    <h1 class="post-title">Exploring x86 ASM : Building my own malloc and free</h1>
    <div class="post-description">Implementing memory management at the lowest level using Linux syscalls</div>
    <div class="post-meta"><span class="meta-item">
  <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar" style="user-select: text;"><rect x="3" y="4" width="18" height="18" rx="2" ry="2" style="user-select: text;"></rect><line x1="16" y1="2" x2="16" y2="6" style="user-select: text;"></line><line x1="8" y1="2" x2="8" y2="6" style="user-select: text;"></line><line x1="3" y1="10" x2="21" y2="10" style="user-select: text;"></line></svg>
  <span>November 17, 2025</span></span>

      
      
    </div>
  </header> 
  <div class="post-content"><p>Since the past few months, I seem to have caught a bug named low-level programming. It started with C++, then I moved on to C. But before long, not even C could scratch the itch of getting ever closer to bare metal. And that is how I ended up here - writing code in pure x86 assembly.</p>
<p>Memory management is a key element of low level programming - yet most developers are, for some reason, irrationally afraid of it. I, on the other hand, am incredibly fascinated by the idea of having the power to manually allocate and deallocate memory at my will.</p>
<p>Most developers take <code>malloc</code> and <code>free</code> for granted - they&rsquo;re just there, doing their job in the background. But what actually happens when you allocate memory? This question is what drove me to strip away all the abstractions and build a minimal allocator from scratch.</p>
<h2 id="the-theory">The Theory<a hidden class="anchor" aria-hidden="true" href="#the-theory">¶</a></h2>
<p>At its core, this allocator relies on two internal Linux system calls:</p>
<h3 id="mmap2---memory-mapping">mmap2 - Memory Mapping<a hidden class="anchor" aria-hidden="true" href="#mmap2---memory-mapping">¶</a></h3>
<p><code>mmap2</code> is the syscall which is used to request memory pages from the kernel. Essentially, you are asking the OS to give your process a specified region of virtual memory. Here is the parameters it takes in:</p>
<ul>
<li><strong>Address</strong>: Where you want the memory (pass 0 to leave it to the kernel)</li>
<li><strong>Length</strong>: What is the size of memory required</li>
<li><strong>Protection</strong>: What operations is the program allowed to do on this memory (e.g. read, write, etc)</li>
<li><strong>Mapping</strong>: How visible is the memory i.e. private to this process, anonymous, etc</li>
<li><strong>File Descriptor</strong>: Which file to map (set to -1 for anonymous memory)</li>
<li><strong>Page Offset</strong>: Offset in the file (must be 0 for anonymous memory)</li>
</ul>
<p>For our implementation, we use <code>PROT_READ | PROT_WRITE</code> with <code>MAP_PRIVATE | MAP_ANONYMOUS</code>, which gives us private read-write memory that isn&rsquo;t backed by any file - exactly what we need for <code>malloc</code>.</p>
<h3 id="munmap---memory-unmapping">munmap - Memory Unmapping<a hidden class="anchor" aria-hidden="true" href="#munmap---memory-unmapping">¶</a></h3>
<p><code>munmap</code> is the inverse operation of <code>mmap2</code>. It tells the OS kernel to deallocate a chunk of memory once we are done using it. Here is the parameters it takes in:</p>
<ul>
<li><strong>Address</strong>: The starting address of the memory region</li>
<li><strong>Length</strong>: The size of the memory region
The kernel then marks those pages as &ldquo;freed&rdquo;, which means that those regions of memory can be reallocated to other programs.</li>
</ul>
<h3 id="the-interface-layer">The Interface Layer<a hidden class="anchor" aria-hidden="true" href="#the-interface-layer">¶</a></h3>
<p>The big idea behind this project is simple - create wrapper functions that interface with these system calls. Instead of the programmer having to fiddle with <code>mmap2</code> flags and protection, he will simply call <code>malloc(size)</code> and <code>free(ptr)</code>.
Another key addition in this implementation is the header. The header is 8 bytes of memory prefixing the allocated memory block - the first four bytes contains the metadata i.e. the size of the memory block, and the next four bytes contains a magic number that is used for validation. This is useful because the <code>munmap</code> syscall requires the length of the memory to be freed, and instead of keeping track of this as a separate variable, we can prefix this in the header itself.</p>
<h2 id="the-implementation">The Implementation<a hidden class="anchor" aria-hidden="true" href="#the-implementation">¶</a></h2>
<p>To start off, we declare some static variables as follows:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-nasm" data-lang="nasm"><span style="display:flex;"><span><span style="color:#66d9ef">section</span> .data
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">MAGIC</span><span style="color:#66d9ef">          equ</span> <span style="color:#ae81ff">0xDEADC0DE</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">HEADER_SIZE</span><span style="color:#66d9ef">    equ</span> <span style="color:#ae81ff">8</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">SYSCALL_mmap2</span><span style="color:#66d9ef">  equ</span> <span style="color:#ae81ff">192</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">SYSCALL_munmap</span><span style="color:#66d9ef"> equ</span> <span style="color:#ae81ff">91</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">PROT_READ</span><span style="color:#66d9ef">      equ</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">PROT_WRITE</span><span style="color:#66d9ef">     equ</span> <span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">PROT_RW</span><span style="color:#66d9ef">        equ</span> (PROT_READ <span style="color:#f92672">|</span> PROT_WRITE)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">MAP_PRIVATE</span><span style="color:#66d9ef">    equ</span> <span style="color:#ae81ff">0x02</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">MAP_ANONYMOUS</span><span style="color:#66d9ef">  equ</span> <span style="color:#ae81ff">0x20</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">MAP_FLAGS</span><span style="color:#66d9ef">      equ</span> (MAP_PRIVATE <span style="color:#f92672">|</span> MAP_ANONYMOUS)
</span></span></code></pre></div><p>Some of these are self explanatory - like <code>MAP_PRIVATE</code> and <code>PROT_READ</code>. The others, we will get into very soon.</p>
<h3 id="the-allocator---malloc">The allocator - <code>malloc</code><a hidden class="anchor" aria-hidden="true" href="#the-allocator---malloc">¶</a></h3>
<p>Our malloc function takes in one parameter over the stack - which is the size of memory to be allocated. As an output, it returns the pointer to the beginning of the memory block in the <code>eax</code> register.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-nasm" data-lang="nasm"><span style="display:flex;"><span>malloc:
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">push</span> ebp                    <span style="color:#75715e">; Prologue</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">mov</span> ebp, esp
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">mov</span> eax, [ebp<span style="color:#f92672">+</span><span style="color:#ae81ff">8</span>]            <span style="color:#75715e">; Load eax with the input param</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">test</span> eax, eax               <span style="color:#75715e">; Check if requested memory size is 0</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">jz</span> .malloc_zero
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">add</span> eax, HEADER_SIZE        <span style="color:#75715e">; Allocate space for the header</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">mov</span> ecx, eax                <span style="color:#75715e">; ecx contains length of memory (for mmap2)</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">xor</span> ebx, ebx                <span style="color:#75715e">; ebx contains address of memory (for mmap2)</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">mov</span> edx, PROT_RW            <span style="color:#75715e">; edx contains protection flags (for mmap2)</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">mov</span> esi, MAP_FLAGS          <span style="color:#75715e">; esi contains mapping flags (for mmap2)</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">mov</span> edi, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>                 <span style="color:#75715e">; edi contains file descriptor (for mmap2)</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">push</span> ebp
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">xor</span> ebp, ebp                <span style="color:#75715e">; ebp contains page offset (for mmap2)</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">mov</span> eax, SYSCALL_mmap2      <span style="color:#75715e">; mmap2 syscall</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">int</span> <span style="color:#ae81ff">0x80</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">pop</span> ebp
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">cmp</span> eax, <span style="color:#ae81ff">0xfffff000</span>         <span style="color:#75715e">; Check if returned pointer is valid</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">jae</span> .malloc_fail
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">mov</span> [eax], ecx              <span style="color:#75715e">; Store the size of memory in header</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">mov</span> <span style="color:#66d9ef">dword</span> [eax <span style="color:#f92672">+</span> <span style="color:#ae81ff">4</span>], MAGIC  <span style="color:#75715e">; Store the magic number in header</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">add</span> eax, HEADER_SIZE        <span style="color:#75715e">; Move the pointer to the start of usable memory</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">mov</span> esp, ebp                <span style="color:#75715e">; Epilogue</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">pop</span> ebp
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">ret</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>.malloc_zero:
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">xor</span> eax, eax                <span style="color:#75715e">; Return a NULL pointer if zero bytes requested</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">mov</span> esp, ebp                <span style="color:#75715e">; Epilogue</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">pop</span> ebp
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">ret</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>.malloc_fail:
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">xor</span> eax, eax                <span style="color:#75715e">; Return a NULL pointer if mmap2 failed</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">mov</span> esp, ebp                <span style="color:#75715e">; Epilogue</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">pop</span> ebp
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">ret</span>
</span></span></code></pre></div><p>When the programmer calls the <code>malloc</code> function, here&rsquo;s what happens:</p>
<ol>
<li><strong>Size validation</strong>: If zero bytes of memory is requested, the function returns NULL immediately.</li>
<li><strong>Header allocation</strong>: It allocates an extra 8 bytes of memory to hold the metadata.</li>
<li><strong>System call</strong>: It calls <code>mmap2</code> to request memory from the kernel with read/write permissions.</li>
<li><strong>Metadata storage</strong>: It stores the size of the allocation and the magic number 0xDEADC0DE in the header.</li>
<li><strong>Pointer adjustment</strong>: It returns a pointer which points to the beginning of the useable memory block.</li>
</ol>
<h3 id="the-deallocator---free">The deallocator - <code>free</code><a hidden class="anchor" aria-hidden="true" href="#the-deallocator---free">¶</a></h3>
<p>Our free function also takes in one parameter over the stack - which is the pointer to the beginning of the memory block to be freed. It deduces the size of the memory block from the header we created earlier.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-nasm" data-lang="nasm"><span style="display:flex;"><span>free:
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">push</span> ebp                    <span style="color:#75715e">; Prologue</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">mov</span> ebp, esp
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">mov</span> eax, [ebp<span style="color:#f92672">+</span><span style="color:#ae81ff">8</span>]            <span style="color:#75715e">; Load eax with the input param</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">test</span> eax, eax               <span style="color:#75715e">; Check if input is NULL pointer</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">jz</span> .free_done
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">sub</span> eax, HEADER_SIZE        <span style="color:#75715e">; Move the pointer back to read the header</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">mov</span> ebx, eax                <span style="color:#75715e">; ebx now points to the size in header</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">mov</span> ecx, [ebx<span style="color:#f92672">+</span><span style="color:#ae81ff">4</span>]            <span style="color:#75715e">; ecx now points to the magic number in header</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">cmp</span> ecx, MAGIC              <span style="color:#75715e">; Validate if magic number is valid</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">jne</span> .bad_magic
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">mov</span> edx, [ebx]              <span style="color:#75715e">; edx contains the size of memory (for munmap)</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">mov</span> eax, SYSCALL_munmap     <span style="color:#75715e">; munmap syscall</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">mov</span> ecx, edx
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">int</span> <span style="color:#ae81ff">0x80</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">jmp</span> .free_done
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>.bad_magic:
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">nop</span>                         <span style="color:#75715e">; Error handling logic if memory is corrupted</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>.free_done:
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">mov</span> esp, ebp                <span style="color:#75715e">; Epilogue</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">pop</span> ebp
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">ret</span>
</span></span></code></pre></div><p>When the programmer calls the <code>free</code> function, here&rsquo;s what happens:</p>
<ol>
<li><strong>NULL check</strong>: If the pointer passed is a NULL pointer, the function does nothing and exits.</li>
<li><strong>Header retrieval</strong>: It goes back 8 bytes in memory from the pointer to deduce the header.</li>
<li><strong>Validation</strong>: It checks for the magic number to detect corruption.</li>
<li><strong>Size retrieval</strong>: It retrieves the size of the block to be freed from the metadata.</li>
<li><strong>System call</strong>: It calls <code>munmap</code> to return the memory back to the operating system.</li>
</ol>
<h2 id="example-usage">Example Usage<a hidden class="anchor" aria-hidden="true" href="#example-usage">¶</a></h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-nasm" data-lang="nasm"><span style="display:flex;"><span>_start:
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">push</span> <span style="color:#66d9ef">dword</span> <span style="color:#ae81ff">4096</span>     <span style="color:#75715e">; Pass 4096 to malloc</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">call</span> malloc
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">mov</span> ebx, eax        <span style="color:#75715e">; Move output pointer to ebx</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">test</span> ebx, ebx       <span style="color:#75715e">; Check if ebx is NULL pointer</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">jz</span> .exit
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">push</span> ebx            <span style="color:#75715e">; Pass ebx to free</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">call</span> free
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>.exit:
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">mov</span> eax, <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">mov</span> ebx, <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">int</span> <span style="color:#ae81ff">0x80</span>
</span></span></code></pre></div><p>Compiling this program with NASM and linking it with ld, we find out that this program compiles without any errors, and more importantly, no SEGFAULTs.
If we run <code>strace</code> on this program, we can see the syscalls made by this program</p>
<pre tabindex="0"><code>mmap2(NULL, 4104, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xf7f56000
munmap(0xf7f56000, 4104)                = 0
exit(0)                                 = ?
</code></pre><p>We can see that the memory allocated is 4096+8 bytes, and the memory freed is corresponding to the memory allocated. Hence, we can conclude that we successfully implemented <code>malloc</code> and <code>free</code>.</p>
<h2 id="conclusion">Conclusion<a hidden class="anchor" aria-hidden="true" href="#conclusion">¶</a></h2>
<p>This project was a fantastic deep-dive into low level memory management. While something like this is completely pointless to be used in production, building it gave me a deeper appreciation for the existing and more sophisticated allocators.
The full source code of this program is available <a href="https://gist.github.com/sayujya-apte/bb9b387283e93012b731c0e621f8f6e8">here</a>.</p>


  </div>

  <footer class="post-footer">
  </footer>
    <div class="comments-separator"></div>
</article>
    </main>
    
<footer class="footer">
  <span>&copy; 2026 <a href="https://sayujya-apte.github.io/">Sayujya Apte</a></span><span style="display: inline-block; margin-left: 1em;">
    <a href="https://creativecommons.org/licenses/by-sa/4.0/">CC BY-SA</a>
  </span>
  <span style="display: inline-block; margin-left: 1em;">
    Powered by
    <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
    <a href="https://github.com/reorx/hugo-PaperModX/" rel="noopener" target="_blank">PaperModX</a>
  </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
    <path d="M12 6H0l6-6z" />
  </svg>
</a>

<script>
  (function() {
     
    const disableThemeToggle = '' == '1';
    if (disableThemeToggle) {
      return;
    }

    let button = document.getElementById("theme-toggle")
    
    button.removeEventListener('click', toggleThemeListener)
    
    button.addEventListener('click', toggleThemeListener)
  })();
</script>

<script>
  (function () {
    let menu = document.getElementById('menu')
    if (menu) {
      menu.scrollLeft = localStorage.getItem("menu-scroll-position");
      menu.onscroll = function () {
        localStorage.setItem("menu-scroll-position", menu.scrollLeft);
      }
    }

    const disableSmoothScroll = '' == '1';
    const enableInstantClick = '' == '1';
    
    if (window.matchMedia('(prefers-reduced-motion: reduce)').matches || disableSmoothScroll || enableInstantClick) {
      return;
    }
    
    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
      anchor.addEventListener("click", function (e) {
        e.preventDefault();
        var id = this.getAttribute("href").substr(1);
        document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
          behavior: "smooth"
        });
        if (id === "top") {
          history.replaceState(null, null, " ");
        } else {
          history.pushState(null, null, `#${id}`);
        }
      });
    });
  })();
</script>
<script>
  var mybutton = document.getElementById("top-link");
  window.onscroll = function () {
    if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
      mybutton.style.visibility = "visible";
      mybutton.style.opacity = "1";
    } else {
      mybutton.style.visibility = "hidden";
      mybutton.style.opacity = "0";
    }
  };
</script>
<script>
  if (window.scrollListeners) {
    
    for (const listener of scrollListeners) {
      window.removeEventListener('scroll', listener)
    }
  }
  window.scrollListeners = []
</script>



<script src="/js/medium-zoom.min.js" data-no-instant
></script>




<script>
  
  
  (function() {
    const enableTocScroll = '' == '1'
    if (!enableTocScroll) {
      return
    }
    if (!document.querySelector('.toc')) {
      console.log('no toc found, ignore toc scroll')
      return
    }
    

    
    const scrollListeners = window.scrollListeners
    const headings = document.querySelectorAll('h1[id],h2[id],h3[id],h4[id],h5[id]');
    const activeClass = 'active';

    
    let activeHeading = headings[0];
    getLinkByHeading(activeHeading).classList.add(activeClass);

    const onScroll = () => {
      const passedHeadings = [];
      for (const h of headings) {
        
        if (getOffsetTop(h) < 5) {
          passedHeadings.push(h)
        } else {
          break;
        }
      }
      if (passedHeadings.length > 0) {
        newActiveHeading = passedHeadings[passedHeadings.length - 1];
      } else {
        newActiveHeading = headings[0];
      }
      if (activeHeading != newActiveHeading) {
        getLinkByHeading(activeHeading).classList.remove(activeClass);
        activeHeading = newActiveHeading;
        getLinkByHeading(activeHeading).classList.add(activeClass);
      }
    }

    let timer = null;
    const scrollListener = () => {
      if (timer !== null) {
        clearTimeout(timer)
      }
      timer = setTimeout(onScroll, 50)
    }
    window.addEventListener('scroll', scrollListener, false);
    scrollListeners.push(scrollListener)

    function getLinkByHeading(heading) {
      const id = encodeURI(heading.getAttribute('id')).toLowerCase();
      return document.querySelector(`.toc ul li a[href="#${id}"]`);
    }

    function getOffsetTop(heading) {
      if (!heading.getClientRects().length) {
        return 0;
      }
      let rect = heading.getBoundingClientRect();
      return rect.top
    }
  })();
  </script>

</body>

</html>
